{
  "hash": "440ac8930abd156f033344f0f4d5df1d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'ETC5513: Collaborative and Reproducible Practices'\nsubtitle: \"Tutorial 7\"\nauthor: \"Michael Lydeamore\"\ndate: today\nformat:\n    unilur-html:\n        output-file: index.html\n        embed-resources: true\n    unilur-html+solution:\n        output-file: solution.html\n        embed-resources: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n# Cleaning Up Your Commit History  \n### With `git rm` and `.gitignore`\n\n## ðŸ§­ Goal\n\nLearn how to remove files from Git tracking with `git rm`, and prevent them from being re-added with a `.gitignore` file.\n\n---\n\n## 1ï¸âƒ£ Create and Clone a Repo\n\n### On GitHub\n\n1. Create a new repository:  \n   ```\n   git-ignore-cleanup\n   ```\n2. âœ… Check \"Add a README file\"\n\n---\n\n### In RStudio\n\n1. Go to **File â†’ New Project â†’ Version Control â†’ Git**\n2. Paste the repo URL (SSH or HTTPS)\n3. Choose a location and click **Create Project**\n\nâœ… You're now working in a Git-tracked project.\n\n---\n\n## 2ï¸âƒ£ Add and Commit a File\n\n1. Create a new `qmd` in RStudio:\n   - Go to **File â†’ New File â†’ Quarto Document**\n\n2. Save the file as `notes.qmd`\n\n3. Add some content like:\n\n   ```r\n   summary(mtcars)\n   ```\n\n4. Stage and commit the file:\n   ```\n   \"Add analysis script\"\n   ```\n\n---\n\n## 3ï¸âƒ£ Accidentally Add a Data File\n\n1. Download the data from Week 2 on Moodle, and save it into your project as `data.csv`\n\n2. Stage and commit:  \n   ```bash\n   git add data.csv\n   git commit -m \"Add raw data\"\n   ```\n\n---\n\n## 4ï¸âƒ£ Remove the File from Git, But Keep It Locally\n\nRealise you **donâ€™t want this in version control**, but you still need it for local use.\n\nIn the terminal:\n\n```bash\ngit rm --cached data.csv\ngit commit -m \"Stop tracking data.csv\"\n```\n\nâœ… `data.csv` is still on your computer, but Git will no longer track it.\n\n---\n\n## 5ï¸âƒ£ Add It to `.gitignore`\n\nTo prevent it from being accidentally added again:\n\n1. Open (or create) a `.gitignore` file in your repo root\n2. Add:\n\n   ```\n   data.csv\n   ```\n\n3. Save and stage the `.gitignore` file\n4. Commit:\n   ```\n   \"Ignore data.csv\"\n   ```\n\n---\n\n## ðŸ” Check It Worked\n\n1. Run:\n\n```bash\ngit status\n```\n\nâœ… You should **not see `data.csv`** listed anywhere â€” Git is now ignoring it.\n\n---\n\n## 3ï¸âƒ£ Squash Commits with Interactive Rebase\n\nLetâ€™s now try squashing a few commits into one clean one.\n\n---\n\n### Step 1: Make a Messy Commit History\n\n1. Edit your `.qmd` file and make **3 separate commits**:\n\n   - Add a new section or chunk â†’ commit: `\"Add section\"`\n   - Fix a typo â†’ commit: `\"Fix typo\"`\n   - Add a final comment â†’ commit: `\"Add footnote\"`\n\nâœ… Commit after each change using the Git pane or terminal.\n\n---\n\n### Step 2: Check Your Commit History\n\nRun in the Terminal:\n\n```bash\ngit log --oneline\n```\n\nYou should see something like:\n\n```\nc3d4e5f Add footnote\nb2c3d4e Fix typo\na1b2c3d Add section\n...\n```\n\n---\n\n### Step 3: Start an Interactive Rebase\n\n```bash\ngit rebase -i HEAD~3\n```\n\nYouâ€™ll see:\n\n```\npick a1b2c3d Add section\npick b2c3d4e Fix typo\npick c3d4e5f Add footnote\n```\n\n---\n\n### Step 4: Squash the Commits\n\nChange it to:\n\n```\npick a1b2c3d Add section\nsquash b2c3d4e\nsquash c3d4e5f\n```\n\nSave and write a new combined commit message like:\n\n```\nAdd section with typo fix and footnote\n```\n\nSave again to finish the rebase.\n\n---\n\n### Step 5: Confirm It Worked\n\nRun:\n\n```bash\ngit log --oneline\n```\n\nâœ… You should now see **one clean commit** where there were three.\n\n---\n\n## ðŸ§  Reflect\n\n- Why is `--amend` useful when working on a single file?\n- When is it good practice to squash commits?\n- What would happen if you did this after pushing?\n\n---\n\n## âœ… Summary\n\n| Action                     | Command                            |\n|----------------------------|-------------------------------------|\n| Fix your last commit       | `git commit --amend`               |\n| Combine multiple commits   | `git rebase -i HEAD~N`             |\n| Keep your history clean    | Use these **before pushing**       |\n\nðŸŽ‰ Youâ€™ve just learned to write cleaner, more professional commit histories!\n\n---\n\n# ðŸ” Extension Activity: Merge vs Rebase\n\n## ðŸ§­ Goal\n\nUnderstand the difference between `git merge` and `git rebase` by applying both to the same branches and comparing the result.\n\n---\n\n## 1ï¸âƒ£ Setup: Create a Feature Branch\n\nIn your GitHub-connected RStudio project:\n\n1. Create a file: `experiment.R`\n2. Add one line:\n   ```\n   Main branch version\n   ```\n3. Save, stage, and commit:\n   ```\n   \"Add base file on main\"\n   ```\n\n4. Create a new branch called `feature`:\n\n```bash\ngit switch -c feature\n```\n\n---\n\n## 2ï¸âƒ£ Add Work on the Feature Branch\n\n1. Edit `experiment.R` again:\n   ```\n   Feature branch addition\n   ```\n\n2. Save and commit:\n   ```\n   \"Add feature content\"\n   ```\n\nâœ… You now have two commits on separate branches.\n\n---\n\n## 3ï¸âƒ£ Add a Change to `main`\n\n1. Switch back to `main`:\n\n```bash\ngit switch main\n```\n\n2. Add to the file again:\n   ```\n   Main branch additional note\n   ```\n\n3. Save and commit:\n   ```\n   \"Add note on main branch\"\n   ```\n\n---\n\n## ðŸ“Š At This Point...\n\nYour Git history looks like this:\n\n```text\n          A---B  (feature)\n         /\n    ---O---C  (main)\n```\n\n- `O` = Original commit\n- `A` = Feature commit\n- `C` = Main branch commit\n- `B` = We'll merge or rebase next\n\n---\n\n## 4ï¸âƒ£ Option A: Merge the Feature Branch\n\n```bash\ngit merge feature\n```\n\nYouâ€™ll get a **merge commit**, like this:\n\n```text\n          A---B  (feature)\n         /     \\\n    ---O---C-----M  (main)\n```\n\nâœ… History shows a clear branching path and merge point.\n\n---\n\n## 5ï¸âƒ£ Option B: Try It Again with Rebase\n\n> This will recreate the same setup and use `rebase` instead of `merge`.\n\n1. Reset the last merge:\n\n```bash\ngit reset --hard HEAD~1\n```\n\n2. Switch to the `feature` branch:\n\n```bash\ngit switch feature\n```\n\n3. Rebase it onto `main`:\n\n```bash\ngit rebase main\n```\n\n4. Now go back to `main` and fast-forward:\n\n```bash\ngit switch main\ngit merge feature\n```\n\n---\n\n## ðŸ“Š After Rebase\n\nYour Git history now looks like:\n\n```text\n    ---O---C---A'  (main, feature)\n```\n\n- `A'` is a new version of A, replayed on top of C\n- No merge commit needed â€” linear history\n\n---\n\n## ðŸ§  Reflect\n\n* Whatâ€™s the key difference between `merge` and `rebase`?  \n* Which history is easier to read?  \n* When is a merge preferred?  \n* Why must you be careful rebasing pushed commits?  \n\n---\n\n## âœ… Summary\n\n| Action                     | Result                            |\n|----------------------------|------------------------------------|\n| `git merge feature`        | Preserves both branches + merge commit |\n| `git rebase main` (on feature) | Rewrites feature history as linear |\n| Use `merge` after pushing  | âœ… Safe for shared work |\n| Use `rebase` before pushing | âœ… Keeps history clean |\n\nðŸŽ‰ You've now seen both strategies in action â€” use the right one for the right job!\n",
    "supporting": [
      "tutorial-07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}