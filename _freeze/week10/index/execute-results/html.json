{
  "hash": "1ebe876ede1dafef35f4f31c8af30292",
  "result": {
    "engine": "knitr",
    "markdown": "---\npagetitle: \"ETC5513: Reproducible and Collaborative Practices\"\nsubtitle: \"Keeping environments separate and reproducible\"\nauthor: \"Michael Lydeamore\"\nemail: \"michael.lydeamore@monash.edu\"\ndate: \"Week 11\"\ndepartment: \"Department of Econometrics and Business Statistics\"\nunit-url: \"rcp.numbat.space\"\nfooter: \"ETC5513 Week 10\"\nformat: \n  revealjs:\n    logo: images/monash-stacked-blue-rgb-transparent.png\n    slide-number: c\n    multiplex: false\n    theme: ../assets/monash.scss\n    show-slide-number: all\n    show-notes: false\n    controls: true\n    width: 1280\n    height: 750\n    css: [../assets/tachyons-addon.css, ../assets/custom.css, ../assets/lecture-01.css]\n    include-after-body: \"../assets/after-body.html\"\n    chalkboard:\n      boardmarker-width: 5\n      buttons: true\nexecute:\n  echo: true\n---\n\n\n\n\n\n\n## <br>[ETC5513: Reproducible and Collaborative Practices]{.monash-blue .title} {#etc5513-title background-image=\"images/bg-01.png\"}\n\n### Keeping environments separate and reproducible\n\nLecturer: *Michael Lydeamore*\n\nDepartment of Econometrics and Business Statistics\n\n::: tl\n<br>\n\n<ul class=\"fa-ul\">\n\n<li>\n\n[<i class=\"fas fa-envelope\"></i>]{.fa-li}michael.lydeamore@monash.edu\n\n</li>\n\n<li>\n\n[<i class=\"fas fa-calendar-alt\"></i>]{.fa-li} Week 11\n\n</li>\n\n<li>\n\n[<i class=\"fa-solid fa-globe\"></i>]{.fa-li}<a href=\"rcp.numbat.space\">rcp.numbat.space</a>\n\n</li>\n\n</ul>\n\n<br>\n:::\n\n## Open Frame\n\n![](images/kelly-sikkema-mdADGzyXCVE-unsplash.jpg){fig-align=\"center\"}\n\n# Environment reproduction\n\n## Why Do We Need This?\n\n- Projects become harder to manage as they grow\n- We want to ensure reproducibility:\n  - Use the same packages and versions\n  - Avoid redundant computation\n- `renv` handles package environments\n- `targets` handles workflow pipelines\n\n---\n\n## ðŸ“¦ What is `renv`?\n\n- `renv` stands for \"Reproducible ENVironments\"\n- Captures your package dependencies\n- Makes your project portable and self-contained\n\n## Libraries and repositories\n\nWe first have to understand what is a _library_ and what is a _repository_.\n\nA _library_ is a directory which contains _all of your install packages_. For us, so far, we have **one** library shared across all of our projects.\n\n::: {.fragment}\nYou can see your current libraries by running `.libPaths()`\n:::\n\n## Libraries and repositories\n\nA _repository_ is a source of packages, such as CRAN. \n\nOther repositories include: Bioconductor, Posit Public Package Manager, and R Universe.\n\n::: {.fragment}\nYou can see your available repositories with `getOption('repos')`\n:::\n\n## Setting up `renv`\n\n```r\ninstall.packages(\"renv\")\nrenv::init()\n```\n\nThis will set up a _project-specific library_, which isolates the packages for each project.\n\n---\n\n## How `renv` Works\n\n- `renv` creates a lockfile (`renv.lock`)\n- Tracks your installed packages and versions\n- You can restore your environment later:\n\n```r\nrenv::restore()\n```\n\n- Keeps packages project-specific (not global)\n\n---\n\n## Key Files from `renv`\n\n- `renv.lock` â€” lists exact package versions\n- `renv/` folder â€” stores the project library\n- `.Rprofile` â€” ensures `renv` is activated when you open the project\n\n::: {.fragment}\nMake sure you check these files in to version control!\n:::\n\n---\n\n## How to use `renv`\n\n- Install packages as normal\n- After each package install, run \n\n```r\nrenv::snapshot()\n```\n\n- Push the changed `renv.lock` file to your repository\n\n---\n\n## The lockfile\n\nHere is an example lockfile:\n\n```\n{\n  \"R\": {\n    \"Version\": \"4.4.3\",\n    \"Repositories\": [\n      {\n        \"Name\": \"CRAN\",\n        \"URL\": \"https://cloud.r-project.org\"\n      }\n    ]\n  },\n  \"Packages\": {\n    \"markdown\": {\n      \"Package\": \"markdown\",\n      \"Version\": \"1.0\",\n      \"Source\": \"Repository\",\n      \"Repository\": \"CRAN\",\n      \"Hash\": \"4584a57f565dd7987d59dda3a02cfb41\"\n    },\n    \"mime\": {\n      \"Package\": \"mime\",\n      \"Version\": \"0.12.1\",\n      \"Source\": \"GitHub\",\n      \"RemoteType\": \"github\",\n      \"RemoteHost\": \"api.github.com\",\n      \"RemoteUsername\": \"yihui\",\n      \"RemoteRepo\": \"mime\",\n      \"RemoteRef\": \"main\",\n      \"RemoteSha\": \"1763e0dcb72fb58d97bab97bb834fc71f1e012bc\",\n      \"Requirements\": [\n        \"tools\"\n      ],\n      \"Hash\": \"c2772b6269924dad6784aaa1d99dbb86\"\n    }\n  }\n}\n```\n\nThere are two main things in here: `R` and `Packages`.\n\nIt is `Packages` that has everything needed to reinstall an exact version of a package.\n\n## Reusing packages across projects\n\nOften we use the same packages across most of our projects. Conveniently, `renv` reuses packages across our projects by maintaining a _cache_.\n\nYou'll see sometimes a message that says:\n\n```\nLinked from Cache\n```\n\nwhen installing. This is the package being re-used!\n\n## Risks of `renv`\n\n`renv` doesn't solve everything for you:\n\n::: {.incremental}\n\n* Doesn't manage R versions\n* When packages become \"old\" they have to be compiled from source\n  * Which is slow\n  * And error prone\n* Doesn't track pandoc\n* Can't help with operating system, system dependencies\n\n:::\n\n\n## Sharing Projects\n\nWhen someone else clones your project:\n\n1. Open the RStudio project\n2. Run:\n\n```r\nrenv::restore()\n```\n\n---\n\n## Using `renv` with GitHub Actions (Advanced)\n\n- GitHub Actions can install your project dependencies automatically\n- `renv::restore()` is run as part of the CI workflow\n- Good for checking that your project runs cleanly on fresh machines\n\n---\n\n## Example GitHub Actions Setup\n\nAdd this to `.github/workflows/ci.yaml`:\n\n```yaml\nname: R-CMD-check\n\non: [push, pull_request]\n\njobs:\n  R-CMD-check:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Set up R\n        uses: r-lib/actions/setup-r@v2\n\n      - name: Install system dependencies\n        run: sudo apt-get update && sudo apt-get install -y libcurl4-openssl-dev libssl-dev libxml2-dev\n\n      - name: Restore packages with renv\n        run: Rscript -e 'install.packages(\"renv\"); renv::restore()'\n\n      - name: Run your script or tests\n        run: Rscript your_script.R\n```\n\nYour GitHub Action will now use the same package versions as your local setup.\n\n---\n\n## When Should You Use This?\n\n- To **check your pipeline still runs** after changes\n- When **collaborating**, to ensure a shared reproducible environment\n- For **automated reports**, like rendering Quarto documents\n\n---\n\n\n# Pipeline management\n\n## The typical pipeline\n\nOften, we end up with something like this:\n\n```\n01-data.R\n02-model.R\n03-plots.R\n```\n\nAnd then we source these in order each time.\n\n::: {.fragment}\nThis works OK for small projects, but scales very poorly.\n:::\n\n## What is `targets`?\n\n- Think **Makefile**, but for R\n- Automates steps in your workflow\n- Re-runs only the steps that need updating\n\n```r\ninstall.packages(\"targets\")\n```\n\n---\n\n## Example Pipeline\n\n```r\nlibrary(targets)\n\nlist(\n  tar_target(data, read_csv(\"data.csv\")),\n  tar_target(model, lm(y ~ x, data))\n)\n```\n\n- Each `tar_target()` defines a step\n- `targets` watches for changes\n\n---\n\n## How It Works\n\nPipeline:\n```\nread_csv() â†’ data â”€â”\n                   â””â”€â”€> lm() â†’ model\n```\n\nIf the file changes, `targets` knows to rerun `read_csv()` and everything downstream.\n\n---\n\n## Running a Pipeline\n\n```r\ntar_make()\n```\n\n- Builds your pipeline\n- Skips steps if inputs havenâ€™t changed\n\n---\n\n## Project Structure Example\n\n```\nyour-project/\nâ”œâ”€â”€ _targets.R     # pipeline definition\nâ”œâ”€â”€ data/\nâ”œâ”€â”€ R/             # helper functions\nâ”œâ”€â”€ renv.lock\nâ”œâ”€â”€ renv/\nâ””â”€â”€ analysis.qmd\n```\n\n---\n\n## How does it work?\n\nWhen running a function, the package _hashes_ the function.\n\nIf the function doesn't change, the hash will stay the same\n\nIf the function has changed, then so too will the hash.\n\n## How does it work\n\nResults are stored on-disk in a compressed format.\n\nTargets can be loaded using `tar_load` or `tar_read` (learn the keybinds!)\n\n## Using `targets` with plots\n\n`_targets.R`\n```r\nlist(\n  tar_target(\n    penguins_plot, \n    ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + geom_point())\n)\n```\n\nIn your console:\n\n```r\ntar_make()\ntar_read(penguins_plot)\n```\n\n::: {.fragment}\n`tar_read` prints the object inside it\n`tar_load` loads the object into your workspace (like using `<-`)\n:::\n\n## `tarchetypes`\n\n`tarchetypes` contains useful functions for working with `targets`\n\nUseful for:\n\n- Dynamic branching\n- Rendering Quarto documents\n- Utility functions\n\n## Dynamic branching\n\nOften we have a dataset where we want to run a pipeline on the groups. In standard R, we do this as follows:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npenguins |>\n  group_by(species) |>\n  summarise(mean_flipper = mean(flipper_length_mm, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n  species   mean_flipper\n  <fct>            <dbl>\n1 Adelie            190.\n2 Chinstrap         196.\n3 Gentoo            217.\n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\n\nIn `targets`-land, we do it like this instead:\n\n```r\nlist(\n  tar_group_by(grouped_penguins, penguins, species), \n  tar_target(\n    mean_flipper, \n    summarise(\n      grouped_penguins, \n      mean_flipper = mean(flipper_length_mm, na.rm=TRUE),\n      species = unique(species)), \n      pattern = map(grouped_penguins))\n)\n```\n\n:::\n\n## Dynamic branching\n\nThis results in \n\n```\n> tar_read(mean_flipper)\n# A tibble: 3 Ã— 2\n  mean_flipper species  \n         <dbl> <fct>    \n1         190. Adelie   \n2         196. Chinstrap\n3         217. Gentoo   \n``` \n\n**Note**: `tarchetypes` will try and row bind these outputs. If your output is not a vector, then you will need `iteration = list` as an argument to the target. We will see this in the workshop!\n:::\n\n## Rendering Quarto documents\n\n::: {.fragment}\nIn this small example, this feels like overkill (and it is), but on large projects, under\n\nYou can also use `targets` in your Quarto documents with\n\n```r\ntar_quarto()\n```\n\nThis will scan your `qmd` file for `tar_target` commands, and load them in the way that you would expect.\n\n## Checking if targets are up to date\n\n```r\ntar_visnetwork()\n```\n\nwill show you outdated, up-to-date, and not yet run targets.\n\nRemember, `targets` only runs what it thinks it needs to!\n\n## Recap\n\n`renv`:\n\n- Tracks your installed packages and versions\n- Keeps packages project-specific (not global)\n\n`targets`:\n\n- Automates steps in your workflow\n- Re-runs only the steps that need updating\n\n::: {.fragment}\nNext week:\n\nDocker!\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}